## FILE: requirements.txt
streamlit
numpy
matplotlib
pandas

## FILE: core/__init__.py
# Este archivo está vacío, pero es necesario para que Python reconozca 'core' como un paquete.

## FILE: core/materials.py
# core/materials.py
import math

DEFAULT_ES = 210000.0  # Módulo de Young del acero (MPa) - Usar 200000 o 210000 según norma aplicable

def calculate_ecm_ec2(fck):
    """Calcula el módulo de elasticidad secante del hormigón según EC2 (MPa)."""
    if fck <= 0:
        return 0
    # Fórmula Ecm = 22 * (fcm / 10)^0.3, donde fcm = fck + 8
    fcm = fck + 8
    ecm = 22000 * math.pow(fcm / 10, 0.3)
    return ecm

def get_modular_ratio(fck, Es=DEFAULT_ES):
    """Calcula la relación modular n = Es / Ecm."""
    Ecm = calculate_ecm_ec2(fck)
    if Ecm <= 1e-9: # Evitar división por cero o valores muy pequeños
        # Considerar lanzar un error o devolver infinito/un valor muy grande
        print(f"Advertencia: Ecm calculado es muy bajo ({Ecm:.2f}) para fck={fck}. La relación modular será muy alta.")
        return float('inf')
    return Es / Ecm

## FILE: core/section_analysis.py
# core/section_analysis.py
import numpy as np
# No necesitamos importar get_modular_ratio aquí si se pasa desde fuera

def calculate_section_properties(shapes, homogenize=False, modular_ratio=None):
    """
    Calcula las propiedades geométricas de una colección de formas.
    Si homogenize es True, transforma el HORMIGÓN a ACERO equivalente
    dividiendo sus propiedades (A, Ix, Iy) por modular_ratio (n=Es/Ecm).
    Requiere que modular_ratio sea proporcionado si homogenize es True.

    Args:
        shapes (list): Lista de objetos SteelPlate y ConcreteTrapezoid.
        homogenize (bool): True para realizar la homogeneización a acero.
        modular_ratio (float, optional): Relación modular n = Es / Ecm. Necesario si homogenize=True.

    Returns:
        dict: Diccionario con 'total_area', 'centroid_x', 'centroid_y',
              'inertia_x', 'inertia_y'.

    Raises:
        ValueError: Si se intenta homogeneizar sin un modular_ratio válido.
    """
    if homogenize and modular_ratio is None:
        raise ValueError("Se requiere 'modular_ratio' para homogeneizar.")
    if homogenize and modular_ratio <= 0:
         raise ValueError("'modular_ratio' debe ser positivo para homogeneizar.")

    total_area = 0.0
    moment_x = 0.0  # Sum(Ai * yi)
    moment_y = 0.0  # Sum(Ai * xi)
    inertia_x_global = 0.0 # Sum(Ix_local_i + Ai * dy_i^2)
    inertia_y_global = 0.0 # Sum(Iy_local_i + Ai * dx_i^2)

    processed_shapes = [] # Guardaremos las propiedades (A, x, y, Ix, Iy) de cada parte

    for shape in shapes:
        try:
            A = shape.area
            x = shape.cg_x
            y = shape.cg_y
            Ix_local = shape.inertia_x_local
            # Manejar posible None de Iy_local en Trapecio o si no está implementado
            Iy_local = shape.inertia_y_local if hasattr(shape, 'inertia_y_local') and shape.inertia_y_local is not None else 0.0
        except AttributeError as e:
             raise AttributeError(f"El objeto {type(shape)} no tiene una propiedad necesaria: {e}")


        if homogenize and shape.material == "concrete":
            # Homogeneizar hormigón a acero dividiendo por n
            # Se asume que Ix e Iy locales escalan con 1/n.
            # (Verificado para Ix, pero Iy puede tener dependencia n^3 para formas como rectángulos)
            # Procedemos con 1/n para ambos por simplicidad inicial, enfocado en Ix.
            if modular_ratio == 0: # Doble chequeo por si acaso
                 raise ValueError("Intento de división por cero en homogeneización (modular_ratio=0).")
            A /= modular_ratio
            Ix_local /= modular_ratio
            Iy_local /= modular_ratio # Precaución con esta simplificación para Iy

        # Las partes de acero no cambian en esta homogeneización
        # else: # shape.material == "steel" or not homogenize
        #     pass # Keep original properties

        # Ignorar formas con área nula o negativa (podría ocurrir con escalas raras)
        if abs(A) > 1e-9: # Usar abs() por si acaso
            processed_shapes.append({'A': A, 'x': x, 'y': y, 'Ix': Ix_local, 'Iy': Iy_local})
            total_area += A
            moment_x += A * y
            moment_y += A * x
        # else: # Opcional: Informar si se ignora una forma
             # print(f"Advertencia: Ignorando forma {type(shape)} con área calculada cercana a cero: {A}")


    if abs(total_area) < 1e-9:
        # Devuelve ceros si el área total es despreciable
        return {'total_area': 0, 'centroid_x': 0, 'centroid_y': 0, 'inertia_x': 0, 'inertia_y': 0}

    # Calcular centroide global
    centroid_x = moment_y / total_area
    centroid_y = moment_x / total_area

    # Calcular inercias globales usando el Teorema de Steiner (Ejes Paralelos)
    for props in processed_shapes:
        dy = props['y'] - centroid_y
        dx = props['x'] - centroid_x
        # Steiner: I_global = Sum( I_local_cg + A * d^2 )
        inertia_x_global += props['Ix'] + props['A'] * dy**2
        inertia_y_global += props['Iy'] + props['A'] * dx**2

    return {
        'total_area': total_area,
        'centroid_x': centroid_x,
        'centroid_y': centroid_y,
        'inertia_x': inertia_x_global, # Inercia respecto al eje X que pasa por el CDG global
        'inertia_y': inertia_y_global  # Inercia respecto al eje Y que pasa por el CDG global
    }

## FILE: shapes/__init__.py
# Este archivo está vacío, pero es necesario para que Python reconozca 'shapes' como un paquete.

## FILE: shapes/steel_plate.py
# shapes/steel_plate.py
import numpy as np

class SteelPlate:
    """Representa una chapa de acero rectangular alineada con los ejes globales X,Y."""
    def __init__(self, width, height, cg_x, cg_y):
        self.width = float(width)   # Dimensión paralela al eje X
        self.height = float(height) # Dimensión paralela al eje Y
        self.cg_x = float(cg_x)
        self.cg_y = float(cg_y)
        self.material = "steel"

        if self.width <= 0 or self.height <= 0:
            raise ValueError("El ancho y alto de la chapa deben ser positivos.")

    @property
    def area(self):
        return self.width * self.height

    @property
    def inertia_x_local(self):
        """Inercia respecto al eje x que pasa por su CDG local (paralelo a X global)."""
        # Eje horizontal por el centroide: b*h^3/12 -> width * height^3 / 12
        return self.width * self.height**3 / 12

    @property
    def inertia_y_local(self):
        """Inercia respecto al eje y que pasa por su CDG local (paralelo a Y global)."""
        # Eje vertical por el centroide: h*b^3/12 -> height * width^3 / 12
        return self.height * self.width**3 / 12

    def get_vertices(self, width_scale_factor=1.0):
        """
        Devuelve las coordenadas de los 4 vértices para dibujar.
        El 'width_scale_factor' solo afecta si se quisiera visualizar
        la homogeneización de acero (normalmente no se hace).
        Aquí escala la dimensión 'width' (paralela a X).
        """
        scaled_width = self.width * width_scale_factor
        half_w = scaled_width / 2
        half_h = self.height / 2 # La altura (paralela a Y) no se escala por defecto

        return [
            (self.cg_x - half_w, self.cg_y - half_h), # Bottom-left
            (self.cg_x + half_w, self.cg_y - half_h), # Bottom-right
            (self.cg_x + half_w, self.cg_y + half_h), # Top-right
            (self.cg_x - half_w, self.cg_y + half_h)  # Top-left
        ]

## FILE: shapes/concrete_trapezoid.py
# shapes/concrete_trapezoid.py
import numpy as np

class ConcreteTrapezoid:
    """
    Representa un trapecio de hormigón, definido por anchos inferior/superior,
    altura y coordenadas del centro de la base inferior.
    Se asume simetría vertical respecto al eje que pasa por el centro de la base inferior.
    """
    def __init__(self, bottom_width, top_width, height, bottom_center_x, bottom_center_y):
        self.b1 = float(bottom_width)  # Ancho inferior
        self.b2 = float(top_width)    # Ancho superior
        self.h = float(height)
        self.bc_x = float(bottom_center_x) # X del centro de la base inferior
        self.bc_y = float(bottom_center_y) # Y del centro (y nivel) de la base inferior
        self.material = "concrete"

        if self.h <= 0:
             raise ValueError("La altura del trapecio debe ser positiva.")
        if self.b1 < 0 or self.b2 < 0:
             raise ValueError("Los anchos del trapecio no pueden ser negativos.")

    @property
    def area(self):
        return (self.b1 + self.b2) / 2 * self.h

    @property
    def cg_y_local(self):
        """Distancia vertical del CDG a la base inferior."""
        sum_b = self.b1 + self.b2
        if abs(sum_b) < 1e-9: # Evitar división por cero si el área es 0 (b1=b2=0)
             # Si el área es cero, el CDG está indefinido, pero podemos devolver la mitad de la altura
             # o manejarlo como un caso especial. Devolver h/2 es razonable.
             return self.h / 2
        # Fórmula para la posición Y del Cdg respecto a la base inferior
        return (self.h / 3) * (self.b1 + 2 * self.b2) / sum_b

    @property
    def cg_x(self):
        """Coordenada X global del CDG (asume simetría respecto al eje vertical que pasa por bc_x)."""
        # Para un trapecio isósceles (o definido simétricamente), el CDG está en el eje de simetría
        return self.bc_x

    @property
    def cg_y(self):
        """Coordenada Y global del CDG."""
        return self.bc_y + self.cg_y_local

    @property
    def inertia_x_local(self):
        """Inercia respecto al eje x que pasa por su CDG local (paralelo a X global)."""
        sum_b = self.b1 + self.b2
        if abs(sum_b) < 1e-9:
            return 0 # Inercia cero si el área es cero
        # Fórmula de la inercia de un trapecio respecto a su eje centroidal horizontal
        return (self.h**3 / 36) * (self.b1**2 + 4 * self.b1 * self.b2 + self.b2**2) / sum_b

    @property
    def inertia_y_local(self):
        """Inercia respecto al eje y que pasa por su CDG local (paralelo a Y global, asume simetría)."""
        # Fórmula para trapecio simétrico respecto al eje vertical centroidal
        # Fuente: https://calcresource.com/moment-of-inertia-trap.html (adaptada a ejes centroidales)
        # Iy = (h / 48) * (b1 + b2) * (b1^2 + b2^2) <-- Esta fórmula parece ser respecto a la base, no centroidal
        # La inercia respecto al eje Y centroidal para un trapecio isósceles es más compleja.
        # I_y_centroidal = (h * (b1^3 + b1^2*b2 + b1*b2^2 + b2^3)) / (36 * (b1+b2)) <-- Verificar!
        # Por simplicidad y foco en Ix, devolveremos None o 0. Implementar si es crucial.
        # print("Advertencia: Iy_local para ConcreteTrapezoid no implementada robustamente (asume 0).")
        sum_b = self.b1 + self.b2
        if abs(sum_b) < 1e-9 or self.h == 0:
            return 0.0

        # Fórmula encontrada (verificar fuente): Iy_cg = h * (b1^3 + b2^3 + b1^2*b2 + b1*b2^2) / (12 * (b1+b2)) - A * (dist_eje_sim_a_cg_x)^2
        # Como asumimos simetría (cg_x = bc_x), la distancia es 0.
        # Iy_cg = h * (b1+b2)*(b1^2+b2^2) / 48  <-- Otra fuente (e.g. Amesweb)
        # Usemos la de Amesweb por simplicidad, PERO VERIFICAR si es centroidal o respecto al eje de simetría.
        # Si es respecto al eje de simetría que pasa por bc_x, está bien si cg_x=bc_x.
        try:
            inertia = (self.h * (self.b1 + self.b2) * (self.b1**2 + self.b2**2)) / 48.0
            return inertia
        except ZeroDivisionError:
            return 0.0
        # return 0.0 # Devolver 0 si no estamos seguros o no es necesaria

    def get_vertices(self, width_scale_factor=1.0):
        """
        Devuelve las coordenadas de los 4 vértices para dibujar.
        El 'width_scale_factor' escala los anchos b1 y b2 (usado para visualizar homogeneización).
        """
        scaled_b1 = self.b1 * width_scale_factor
        scaled_b2 = self.b2 * width_scale_factor
        half_b1 = scaled_b1 / 2
        half_b2 = scaled_b2 / 2
        # bc_x es el centro de la base inferior original. El escalado se hace simétrico respecto a él.
        return [
            (self.bc_x - half_b1, self.bc_y),             # Bottom-left
            (self.bc_x + half_b1, self.bc_y),             # Bottom-right
            (self.bc_x + half_b2, self.bc_y + self.h),    # Top-right
            (self.bc_x - half_b2, self.bc_y + self.h)     # Top-left
        ]

## FILE: shapes/rotated_steel_plate.py
# shapes/rotated_steel_plate.py
import numpy as np
import math

class RotatedSteelPlate:
    """
    Representa una chapa de acero rectangular con un espesor, definida por:
    1) Punto inicial, punto final y espesor.
    2) Punto inicial, vector director, longitud y espesor.
    La chapa puede estar rotada en el plano XY.
    """
    def __init__(self, thickness, p1=None, p2=None, vector=None, length=None):
        """
        Inicializa la chapa rotada.

        Args:
            thickness (float): Espesor de la chapa (será el 'ancho' local).
            p1 (tuple, optional): Coordenadas (x1, y1) del punto inicial. Requerido si no se usa vector/length.
            p2 (tuple, optional): Coordenadas (x2, y2) del punto final. Requerido si no se usa vector/length.
            vector (tuple, optional): Vector director (vx, vy). Usado con p1 y length.
            length (float, optional): Longitud de la chapa. Usado con p1 y vector.

        Raises:
            ValueError: Si los argumentos de entrada no son suficientes o son inconsistentes.
        """
        self.t = float(thickness)
        self.material = "steel"

        if self.t <= 0:
             raise ValueError("El espesor de la chapa debe ser positivo.")

        if p1 is None:
            raise ValueError("El punto inicial 'p1' es requerido.")
        self.p1 = np.array(p1, dtype=float)

        if p2 is not None:
            # Definición por p1 y p2
            self.p2 = np.array(p2, dtype=float)
            if vector is not None or length is not None:
                # Permitir pero advertir puede ser peligroso si los datos son inconsistentes.
                # Mejor ser estricto o elegir una prioridad clara.
                print("Advertencia: Se proporcionaron p1/p2 y vector/length. Se usarán p1 y p2.")
            diff = self.p2 - self.p1
            self.L = np.linalg.norm(diff)
            if self.L < 1e-9:
                raise ValueError("Los puntos p1 y p2 son coincidentes (longitud cero).")
            # Vector director unitario
            self.u_dir = diff / self.L
        elif vector is not None and length is not None:
            # Definición por p1, vector y length
            self.L = float(length)
            if self.L <= 0:
                raise ValueError("La longitud 'length' debe ser positiva.")
            v = np.array(vector, dtype=float)
            v_norm = np.linalg.norm(v)
            if v_norm < 1e-9:
                raise ValueError("El vector director no puede ser cero.")
            # Vector director unitario
            self.u_dir = v / v_norm
            self.p2 = self.p1 + self.L * self.u_dir
        else:
            raise ValueError("Debe proporcionar 'p2' o ('vector' y 'length').")

        # Calcular ángulo con el eje X global (en radianes)
        self.theta = math.atan2(self.u_dir[1], self.u_dir[0])

        # Calcular centro de gravedad (punto medio del eje longitudinal)
        self.cg_x = (self.p1[0] + self.p2[0]) / 2
        self.cg_y = (self.p1[1] + self.p2[1]) / 2

    @property
    def area(self):
        """Área de la chapa."""
        return self.L * self.t

    # --- Propiedades de Inercia ---
    # Calculamos Ix e Iy respecto a ejes paralelos a los globales X,Y
    # pero que pasan por el CDG de la chapa.

    @property
    def inertia_x_local(self):
        """Inercia respecto a eje X' // X global, pasando por CDG local."""
        # Iu = Inercia sobre eje longitudinal (u) = t * L^3 / 12
        # Iv = Inercia sobre eje transversal (v) = L * t^3 / 12
        # Nota: 'u' es el eje a lo largo de L, 'v' es el eje a lo largo de t.
        Iu = self.t * self.L**3 / 12
        Iv = self.L * self.t**3 / 12
        sin_t = math.sin(self.theta)
        cos_t = math.cos(self.theta)
        # Fórmula de rotación de tensor de inercia:
        # Ix_cg = (Iu+Iv)/2 + (Iu-Iv)/2 * cos(2*theta) <-- Incorrecto para ejes X,Y
        # Usando transformación directa: Ix_cg = Iu*sin^2(theta) + Iv*cos^2(theta)
        return Iu * sin_t**2 + Iv * cos_t**2

    @property
    def inertia_y_local(self):
        """Inercia respecto a eje Y' // Y global, pasando por CDG local."""
        Iu = self.t * self.L**3 / 12
        Iv = self.L * self.t**3 / 12
        sin_t = math.sin(self.theta)
        cos_t = math.cos(self.theta)
        # Iy_cg = Iu*cos^2(theta) + Iv*sin^2(theta)
        return Iu * cos_t**2 + Iv * sin_t**2

    # @property
    # def inertia_xy_local(self):
    #     """Producto de inercia respecto a ejes X', Y' // globales por CDG."""
    #     # Ixy_cg = (Iu - Iv) * sin(theta) * cos(theta)
    #     Iu = self.t * self.L**3 / 12
    #     Iv = self.L * self.t**3 / 12
    #     sin_t = math.sin(self.theta)
    #     cos_t = math.cos(self.theta)
    #     return (Iu - Iv) * sin_t * cos_t
        # NOTA: La función de análisis de sección actual no usa Ixy_local.

    def get_vertices(self, width_scale_factor=1.0):
        """
        Devuelve las coordenadas de los 4 vértices de la chapa rectangular.
        El 'width_scale_factor' escala el espesor (t).
        """
        scaled_t = self.t * width_scale_factor
        if scaled_t < 0: scaled_t = 0 # Evitar espesor negativo
        half_t = scaled_t / 2

        # Vector normal (perpendicular a u_dir, longitud 1)
        # Rotar u_dir 90 grados: (x, y) -> (-y, x)
        u_norm = np.array([-self.u_dir[1], self.u_dir[0]])

        # Calcular los 4 vértices usando p1, p2 y el vector normal escalado
        v1 = self.p1 + half_t * u_norm
        v2 = self.p2 + half_t * u_norm
        v3 = self.p2 - half_t * u_norm
        v4 = self.p1 - half_t * u_norm

        # Devolver como lista de tuplas
        return [tuple(v1), tuple(v2), tuple(v3), tuple(v4)]

## FILE: visualization/__init__.py
# Este archivo está vacío, pero es necesario para que Python reconozca 'visualization' como un paquete.

## FILE: visualization/plot_section.py
# visualization/plot_section.py
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
import math

def plot_section(shapes, title="Sección Transversal", highlight_centroid=None, centroid_label="CDG",
                 homogenize_visual=False, modular_ratio=None):
    """
    Dibuja la sección transversal usando Matplotlib.
    Puede dibujar la sección original o una visualización homogeneizada (Hormigón->Acero).

    Args:
        shapes (list): Lista de objetos de forma (deben tener .material, .get_vertices(), y opcionalmente .cg_x, .cg_y).
        title (str): Título del gráfico.
        highlight_centroid (dict, optional): Coordenadas {'x': xc, 'y': yc} a resaltar.
        centroid_label (str): Etiqueta para el centroide resaltado.
        homogenize_visual (bool): Si True, dibuja la visualización homogeneizada
                                   (Hormigón con ancho / n). Requiere modular_ratio.
        modular_ratio (float, optional): n=Es/Ecm, necesario si homogenize_visual es True.
    """
    if homogenize_visual and (modular_ratio is None or modular_ratio <= 0):
        # Manejar caso inválido, quizás dibujando la original o mostrando error
        print(f"Advertencia: modular_ratio inválido ({modular_ratio}) para visualización homogeneizada. Dibujando original.")
        homogenize_visual = False # Dibujar la original como fallback
        # O podríamos lanzar un error:
        # raise ValueError("Se requiere 'modular_ratio' positivo para la visualización homogeneizada.")


    fig, ax = plt.subplots(figsize=(8, 8))
    all_vertices = []
    legend_handles = {} # Para evitar leyendas duplicadas

    for shape in shapes:
        scale_factor = 1.0
        color = 'grey' # Default color
        hatch = None   # Default hatch
        base_label = "Desconocido" # Default label

        # Determinar estilo basado en material y si se visualiza homogeneización
        is_concrete = hasattr(shape, 'material') and shape.material == "concrete"
        is_steel = hasattr(shape, 'material') and shape.material == "steel"

        label_suffix = ""
        if is_steel:
             color = 'lightblue'
             hatch = '//'
             base_label = 'Acero'
        elif is_concrete:
             color = 'lightgrey'
             hatch = '..'
             base_label = 'Hormigón'
             if homogenize_visual:
                 scale_factor = 1.0 / modular_ratio
                 # Cambiar estilo para hormigón homogeneizado visualmente
                 color = 'lightcoral' # Diferente color
                 hatch = 'xx'
                 label_suffix = f' (Ancho/{modular_ratio:.2f})' # Añadir info a la etiqueta

        # Obtener vértices (escalados si es necesario)
        try:
            vertices = shape.get_vertices(width_scale_factor=scale_factor)
            all_vertices.extend(vertices)
        except TypeError: # Si get_vertices no acepta el argumento (clases antiguas?)
             print(f"Advertencia: {type(shape)}.get_vertices no acepta width_scale_factor. Usando factor 1.0.")
             vertices = shape.get_vertices()
             all_vertices.extend(vertices)
        except Exception as e:
            print(f"Error obteniendo vértices para {type(shape)}: {e}. Saltando forma.")
            continue # Saltar esta forma si no se pueden obtener los vértices


        # Dibujar el polígono
        final_label = f"{base_label}{label_suffix}"
        # closed=True es el default para Polygon, pero lo ponemos explícito
        poly = patches.Polygon(vertices, closed=True, facecolor=color, edgecolor='black', hatch=hatch)
        ax.add_patch(poly)

        # Añadir a leyenda si es la primera vez que vemos este tipo/material/estado
        if final_label not in legend_handles:
             legend_handles[final_label] = poly # Guardar el patch para la leyenda

        # Anotar CDG original de la parte (siempre sobre la geometría original, si no es visualización homog.)
        # y si la forma tiene las propiedades cg_x, cg_y
        if not homogenize_visual and hasattr(shape, 'cg_x') and hasattr(shape, 'cg_y'):
             try:
                 ax.plot(shape.cg_x, shape.cg_y, 'ko', markersize=3, label='_nolegend_') # k=black, o=circle, no en leyenda
             except Exception as e:
                 print(f"Advertencia: No se pudo dibujar CDG para {type(shape)}: {e}")


    # Configurar límites y aspecto del gráfico
    if not all_vertices:
        # Poner límites por defecto si no hay formas
        ax.set_xlim(-100, 100)
        ax.set_ylim(-100, 100)
    else:
        # Autoajustar límites con un margen generoso
        all_x = [v[0] for v in all_vertices]
        all_y = [v[1] for v in all_vertices]
        min_x, max_x = min(all_x), max(all_x)
        min_y, max_y = min(all_y), max(all_y)
        delta_x = max(max_x - min_x, 10) # Mínimo rango de 10 para evitar márgenes enormes en formas pequeñas
        delta_y = max(max_y - min_y, 10)
        margin_x = delta_x * 0.1 + 5 # Margen proporcional + absoluto mínimo
        margin_y = delta_y * 0.1 + 5
        ax.set_xlim(min_x - margin_x, max_x + margin_x)
        ax.set_ylim(min_y - margin_y, max_y + margin_y)

    # Dibujar centroide global resaltado si se proporciona
    if highlight_centroid and isinstance(highlight_centroid, dict) and 'x' in highlight_centroid and 'y' in highlight_centroid:
        try:
            cx, cy = highlight_centroid['x'], highlight_centroid['y']
            # Usar un marcador distinto y color llamativo
            marker_style = 'X' # 'X' o 'P' (plus) son visibles
            marker_color = 'red'
            marker_size = 10
            marker = ax.plot(cx, cy, marker=marker_style, color=marker_color, markersize=marker_size, linestyle='None', label=centroid_label)[0]
            # Añadir texto cerca del marcador
            ax.text(cx, cy, f'  {centroid_label}', color=marker_color, va='bottom', ha='left', fontsize=9, fontweight='bold')
            # Añadir a la leyenda si no estaba ya (poco probable con etiqueta única)
            if centroid_label not in legend_handles:
                 legend_handles[centroid_label] = marker
        except Exception as e:
            print(f"Advertencia: No se pudo dibujar el centroide resaltado ({centroid_label}): {e}")


    # Configuración final del plot
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlabel("Coordenada X (mm)")
    ax.set_ylabel("Coordenada Y (mm)")
    ax.set_title(title, fontsize=12, fontweight='bold')
    ax.grid(True, linestyle=':', linewidth=0.5, color='gray', alpha=0.7) # Estilo de rejilla más sutil
    # Crear leyenda única a partir de los handles guardados
    if legend_handles:
         ax.legend(legend_handles.values(), legend_handles.keys(), loc='best', fontsize=9)

    # Devolver la figura de matplotlib
    return fig

## FILE: main_app.py
# main_app.py
import streamlit as st
import pandas as pd
import numpy as np
import math # Necesario para RotatedSteelPlate

# Importaciones (asumiendo estructura de carpetas correcta)
# Intentar importaciones relativas si se ejecuta como módulo, si no, directas.
try:
    from .core.materials import calculate_ecm_ec2, get_modular_ratio, DEFAULT_ES
    from .core.section_analysis import calculate_section_properties
    from .shapes.steel_plate import SteelPlate # Chapa original (alineada con ejes)
    from .shapes.concrete_trapezoid import ConcreteTrapezoid
    from .shapes.rotated_steel_plate import RotatedSteelPlate # ¡Nueva clase!
    from .visualization.plot_section import plot_section
except ImportError:
    # Fallback si se ejecuta como script simple (streamlit run main_app.py)
    from core.materials import calculate_ecm_ec2, get_modular_ratio, DEFAULT_ES
    from core.section_analysis import calculate_section_properties
    from shapes.steel_plate import SteelPlate # Chapa original (alineada con ejes)
    from shapes.concrete_trapezoid import ConcreteTrapezoid
    from shapes.rotated_steel_plate import RotatedSteelPlate # ¡Nueva clase!
    from visualization.plot_section import plot_section


# Configuración de la página de Streamlit
st.set_page_config(
    page_title="Análisis de Secciones Mixtas",
    page_icon="🏗️",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- Estado de la Sesión ---
# Inicializar listas de formas si no existen
if 'shapes' not in st.session_state:
    st.session_state.shapes = []
if 'undo_stack' not in st.session_state:
     st.session_state.undo_stack = [] # Para posible función de deshacer

# --- Funciones Auxiliares ---
def add_shape(shape_object):
    """Añade una forma a la lista y guarda el estado anterior para deshacer."""
    # Guardar estado actual antes de añadir
    current_shapes_copy = [s for s in st.session_state.shapes] # Copia superficial es suficiente
    st.session_state.undo_stack.append(current_shapes_copy)
    # Limitar tamaño del historial de deshacer (opcional)
    max_undo = 10
    if len(st.session_state.undo_stack) > max_undo:
         st.session_state.undo_stack.pop(0) # Eliminar el más antiguo

    # Añadir la nueva forma
    st.session_state.shapes.append(shape_object)

def undo_last_action():
    """Restaura el estado anterior de las formas."""
    if st.session_state.undo_stack:
        previous_shapes = st.session_state.undo_stack.pop()
        st.session_state.shapes = previous_shapes
        st.success("Última acción deshecha.")
        st.rerun() # Forzar actualización de la UI
    else:
        st.warning("No hay acciones que deshacer.")

# --- Interfaz Principal ---
st.title("📊 Analizador de Propiedades de Secciones Mixtas")
st.write("Herramienta para calcular propiedades geométricas de secciones compuestas Hormigón-Acero.")
st.write("*(Homogeneización: Hormigón transformado a Acero equivalente)*")


# --- Columnas para layout ---
col_input, col_results = st.columns([1, 1.5]) # Dar más espacio a resultados/plots

# --- Columna de Entrada ---
with col_input:
    st.header("🏗️ Definición de la Sección")

    # --- Materiales ---
    with st.container(border=True): # Agrupar visualmente
        st.subheader("GPa | Materiales")
        c1, c2 = st.columns(2)
        with c1:
            fck = st.number_input(
                "Hormigón, $f_{ck}$ (MPa)",
                min_value=12.0, max_value=90.0, value=30.0, step=1.0,
                help="Resistencia característica del hormigón a compresión."
            )
        with c2:
            Es = st.number_input(
                "Acero, $E_s$ (MPa)",
                value=DEFAULT_ES, format="%f", step=1000.0,
                help="Módulo de elasticidad del acero estructural."
            )

        # Calcular y mostrar propiedades derivadas
        try:
            n = get_modular_ratio(fck, Es) # n = Es / Ecm
            if n == float('inf') or n <= 0:
                 st.error(f"Relación modular n inválida ({n:.2f}). Verifique fck.")
                 Ecm = 0
            else:
                 Ecm = Es / n
                 st.info(f"$E_{{cm}} = {Ecm:.1f}$ MPa | $n = E_s / E_{{cm}} = {n:.2f}$")
        except Exception as e:
            st.error(f"Error calculando propiedades de materiales: {e}")
            n = 0 # Valor inválido para evitar cálculos posteriores

    # --- Geometría (Añadir Componentes) ---
    st.subheader("📐 Geometría")

    tab_aligned, tab_rotated, tab_concrete = st.tabs(["Chapa Alineada", "Chapa Rotada", "Hormigón Trapecio"])

    # Formulario Chapa Acero (alineada con ejes)
    with tab_aligned:
         with st.form("steel_form_aligned", clear_on_submit=True, border=False):
            st.write("**Chapa rectangular alineada con ejes X, Y.**")
            c1, c2 = st.columns(2)
            s_width = c1.number_input("Ancho (en X) [mm]", min_value=0.1, value=100.0, key="s_w_aligned")
            s_height = c2.number_input("Alto (en Y) [mm]", min_value=0.1, value=10.0, key="s_h_aligned")
            c1, c2 = st.columns(2)
            s_cg_x = c1.number_input("Coord. X del CDG [mm]", value=0.0, format="%f", key="s_x_aligned")
            s_cg_y = c2.number_input("Coord. Y del CDG [mm]", value=0.0, format="%f", key="s_y_aligned")

            submitted = st.form_submit_button("➕ Añadir Chapa Alineada", use_container_width=True)
            if submitted:
                try:
                    new_plate = SteelPlate(s_width, s_height, s_cg_x, s_cg_y)
                    add_shape(new_plate) # Usar función auxiliar para añadir con deshacer
                    st.success("Chapa de acero alineada añadida.")
                    st.rerun() # Actualizar UI inmediatamente
                except ValueError as ve:
                    st.error(f"Error: {ve}")
                except Exception as e:
                    st.error(f"Error inesperado al añadir chapa alineada: {e}")

    # Formulario Chapa Acero Rotada
    with tab_rotated:
        with st.form("steel_form_rotated", clear_on_submit=True, border=False):
            st.write("**Chapa rectangular con orientación genérica.**")
            rot_t = st.number_input("Espesor [mm]", min_value=0.1, value=10.0, key="rot_t")

            definition_method = st.radio(
                "Definir por:",
                ('Punto Inicial y Final', 'Punto Inicial, Vector y Longitud'),
                key="rot_method", horizontal=True
            )

            c1, c2 = st.columns(2)
            rot_p1_x = c1.number_input("P1 - Coord. X [mm]", value=-50.0, format="%f", key="rot_p1x")
            rot_p1_y = c2.number_input("P1 - Coord. Y [mm]", value=-50.0, format="%f", key="rot_p1y")

            if definition_method == 'Punto Inicial y Final':
                c1, c2 = st.columns(2)
                rot_p2_x = c1.number_input("P2 - Coord. X [mm]", value=50.0, format="%f", key="rot_p2x")
                rot_p2_y = c2.number_input("P2 - Coord. Y [mm]", value=50.0, format="%f", key="rot_p2y")
                rot_vector_x, rot_vector_y, rot_length = None, None, None
            else: # 'Punto Inicial, Vector y Longitud'
                c1, c2, c3 = st.columns(3)
                rot_vector_x = c1.number_input("Vector X", value=1.0, format="%f", key="rot_vx")
                rot_vector_y = c2.number_input("Vector Y", value=1.0, format="%f", key="rot_vy")
                rot_length = c3.number_input("Longitud [mm]", min_value=0.1, value=141.42, format="%f", key="rot_l")
                rot_p2_x, rot_p2_y = None, None

            submitted = st.form_submit_button("➕ Añadir Chapa Rotada", use_container_width=True)
            if submitted:
                try:
                    if definition_method == 'Punto Inicial y Final':
                        new_rotated_plate = RotatedSteelPlate(
                            thickness=rot_t, p1=(rot_p1_x, rot_p1_y), p2=(rot_p2_x, rot_p2_y)
                        )
                    else:
                        new_rotated_plate = RotatedSteelPlate(
                            thickness=rot_t, p1=(rot_p1_x, rot_p1_y), vector=(rot_vector_x, rot_vector_y), length=rot_length
                        )
                    add_shape(new_rotated_plate)
                    st.success("Chapa de acero rotada añadida.")
                    st.rerun()
                except ValueError as ve:
                     st.error(f"Error: {ve}")
                except Exception as e:
                    st.error(f"Error inesperado: {e}")


    # Formulario Trapecio Hormigón
    with tab_concrete:
         with st.form("concrete_form", clear_on_submit=True, border=False):
            st.write("**Trapecio de hormigón (simétrico).**")
            c1, c2 = st.columns(2)
            c_b1 = c1.number_input("Ancho inferior, b1 [mm]", min_value=0.0, value=300.0, format="%f", key="c_b1")
            c_b2 = c2.number_input("Ancho superior, b2 [mm]", min_value=0.0, value=300.0, format="%f", key="c_b2")
            c1, c2 = st.columns(2)
            c_h = c1.number_input("Altura, h [mm]", min_value=0.1, value=200.0, format="%f", key="c_h")
            # c2 queda libre o para otro input
            c1, c2 = st.columns(2)
            c_bc_x = c1.number_input("X centro base inf. [mm]", value=0.0, format="%f", key="c_bx")
            c_bc_y = c2.number_input("Y centro base inf. [mm]", value=0.0, format="%f", key="c_by")

            submitted = st.form_submit_button("➕ Añadir Trapecio", use_container_width=True)
            if submitted:
                try:
                    new_trapezoid = ConcreteTrapezoid(c_b1, c_b2, c_h, c_bc_x, c_bc_y)
                    add_shape(new_trapezoid)
                    st.success("Trapecio de hormigón añadido.")
                    st.rerun()
                except ValueError as ve:
                    st.error(f"Error: {ve}")
                except Exception as e:
                     st.error(f"Error inesperado al añadir trapecio: {e}")

    # --- Lista de Componentes Añadidos ---
    st.subheader("🧩 Componentes Actuales")
    if not st.session_state.shapes:
        st.info("Añade componentes usando las pestañas de arriba.")
    else:
        # Usamos un contenedor con altura fija y scroll si hay muchos elementos
        with st.container(height=300, border=True):
            indices_a_borrar = []
            for i, shape in enumerate(st.session_state.shapes):
                col1, col2 = st.columns([0.9, 0.1]) # Columna pequeña para botón borrar
                shape_desc = f"**{i+1}:** "
                try:
                    if isinstance(shape, SteelPlate):
                         shape_desc += f"Chapa Alineada (Acero): A={shape.width:.1f}, H={shape.height:.1f}, CDG=({shape.cg_x:.1f}, {shape.cg_y:.1f})"
                    elif isinstance(shape, RotatedSteelPlate):
                         shape_desc += f"Chapa Rotada (Acero): L={shape.L:.1f}, t={shape.t:.1f}, θ={math.degrees(shape.theta):.1f}°, CDG=({shape.cg_x:.1f}, {shape.cg_y:.1f})"
                    elif isinstance(shape, ConcreteTrapezoid):
                         shape_desc += f"Trapecio (Horm.): b1={shape.b1:.1f}, b2={shape.b2:.1f}, h={shape.h:.1f}, Base=({shape.bc_x:.1f}, {shape.bc_y:.1f})"
                    else:
                         shape_desc += f"Tipo {type(shape).__name__}"
                except Exception as e:
                     shape_desc += f"Error al describir forma: {e}"

                col1.write(shape_desc)

                # Usamos un botón icono para borrar
                if col2.button("🗑️", key=f"del_{i}", help="Eliminar este componente"):
                     indices_a_borrar.append(i)

            # Borrar elementos si se hizo click en algún botón
            if indices_a_borrar:
                # Guardar estado actual para deshacer el borrado
                current_shapes_copy = [s for s in st.session_state.shapes]
                st.session_state.undo_stack.append(current_shapes_copy)
                 # Limitar tamaño del historial
                max_undo = 10
                if len(st.session_state.undo_stack) > max_undo:
                     st.session_state.undo_stack.pop(0)

                # Borrar en orden inverso para no afectar índices restantes
                for index in sorted(indices_a_borrar, reverse=True):
                    st.session_state.shapes.pop(index)
                st.success(f"Eliminado(s) {len(indices_a_borrar)} componente(s).")
                st.rerun()

    # Botón de deshacer (si hay algo en la pila)
    if st.session_state.undo_stack:
         if st.button("↩️ Deshacer Última Adición/Borrado", use_container_width=True):
              undo_last_action()


# --- Columna de Resultados ---
with col_results:
    st.header("📊 Resultados del Análisis")

    if st.session_state.shapes and n > 0:
        try:
            # Calcular propiedades originales
            props_orig = calculate_section_properties(st.session_state.shapes, homogenize=False)

            # Calcular propiedades homogeneizadas (Hormigón -> Acero)
            props_homog = calculate_section_properties(st.session_state.shapes, homogenize=True, modular_ratio=n)

            # Mostrar tabla de resultados
            st.subheader("📈 Propiedades Geométricas")

            # Formatear números con separadores de miles y decimales
            def format_num(value, precision=2, is_area=False, is_inertia=False):
                try:
                    num = float(value)
                    if is_inertia:
                        return f"{num:,.{precision}e} mm⁴" # Notación científica para inercia
                    unit = " mm²" if is_area else " mm"
                    return f"{num:,.{precision}f}{unit}"
                except (ValueError, TypeError):
                     # Casos como "N/A" o errores
                     return str(value) if value is not None else "Error"

            data = {
                'Propiedad': [
                    'Área Total (A)',
                    'Centroide X (Xg)',
                    'Centroide Y (Yg)',
                    'Inercia Ix (CDG)',
                    'Inercia Iy (CDG)'
                ],
                'Sección Original': [
                    format_num(props_orig['total_area'], precision=1, is_area=True),
                    format_num(props_orig['centroid_x']),
                    format_num(props_orig['centroid_y']),
                    format_num(props_orig['inertia_x'], precision=3, is_inertia=True) if props_orig['inertia_x'] != 0 else "N/A",
                    format_num(props_orig['inertia_y'], precision=3, is_inertia=True) if props_orig['inertia_y'] != 0 else "N/A"
                ],
                'Sección Homogeneizada (a Acero)': [
                    format_num(props_homog['total_area'], precision=1, is_area=True) + " (eq. Acero)",
                    format_num(props_homog['centroid_x']),
                    format_num(props_homog['centroid_y']),
                    format_num(props_homog['inertia_x'], precision=3, is_inertia=True) + " (eq. Acero)" if props_homog['inertia_x'] != 0 else "N/A",
                    format_num(props_homog['inertia_y'], precision=3, is_inertia=True) + " (eq. Acero)" if props_homog['inertia_y'] != 0 else "N/A"
                ]
            }
            # Crear DataFrame y mostrar como tabla Markdown para mejor formato
            df_results = pd.DataFrame(data)
            st.markdown(df_results.to_markdown(index=False), unsafe_allow_html=True) # Usar markdown

            # --- Visualización ---
            st.subheader("🖼️ Visualización")

            # Usar pestañas para las dos vistas
            tab_vis_orig, tab_vis_homog = st.tabs(["Sección Original", "Visualización Homogeneizada"])

            with tab_vis_orig:
                 st.write("Geometría original. El punto rojo marca el CDG global original.")
                 try:
                     fig_orig = plot_section(
                         st.session_state.shapes,
                         title="Sección Original",
                         highlight_centroid={'x': props_orig['centroid_x'], 'y': props_orig['centroid_y']},
                         centroid_label="CDG Orig."
                     )
                     st.pyplot(fig_orig)
                 except Exception as plot_err:
                      st.error(f"Error al generar gráfico original: {plot_err}")

            with tab_vis_homog:
                 st.write(f"Visualización con hormigón escalado (ancho / n={n:.2f}). Punto rojo marca CDG homogeneizado.")
                 try:
                     fig_homog_vis = plot_section(
                         st.session_state.shapes,
                         title="Visualización Homogeneizada (Hormigón -> Acero)",
                         homogenize_visual=True,
                         modular_ratio=n,
                         highlight_centroid={'x': props_homog['centroid_x'], 'y': props_homog['centroid_y']},
                         centroid_label="CDG Homog."
                     )
                     st.pyplot(fig_homog_vis)
                 except Exception as plot_err:
                      st.error(f"Error al generar gráfico homogeneizado: {plot_err}")

        except ValueError as ve: # Errores de cálculo (e.g., n inválido pasado a cálculo)
            st.error(f"Error en los cálculos: {ve}")
        except AttributeError as ae: # Errores si una forma no tiene propiedades requeridas
             st.error(f"Error en definición de forma: {ae}")
        except Exception as e: # Otros errores inesperados
            st.error(f"Error inesperado durante el análisis: {e}")
            # Opcional: Mostrar traceback para depuración
            # import traceback
            # st.code(traceback.format_exc())

    elif not st.session_state.shapes:
        st.info("Añada componentes geométricos para ver los resultados y la visualización.")
    elif n <= 0:
         st.error("La relación modular 'n' no es válida. Verifique fck y Es para continuar con el análisis.")

# --- Pié de Página o Sidebar ---
st.sidebar.header("Acerca de")
st.sidebar.info(
    """
    **Analizador de Secciones Mixtas v0.3**

    Calcula propiedades geométricas de secciones compuestas.
    - **Homogeneización:** Hormigón -> Acero (Area, Ix, Iy escalados por 1/n).
    - **Inercias:** Respecto a ejes centroidales globales.
    - **Visualización:** Geometría original y homogeneizada (hormigón escalado).
    """
)
st.sidebar.markdown("---")
# Añadir fecha y lugar dinámicamente si se desea, o dejarlo estático
# from datetime import datetime
# now = datetime.now()
# current_date_str = now.strftime("%A, %d de %B de %Y")
# st.sidebar.markdown(f"*Generado el {current_date_str}*")
st.sidebar.markdown("*(Lunes, 21 de Abril de 2025 - Cáceres, España)*")