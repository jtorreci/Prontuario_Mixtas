## FILE: requirements.txt
streamlit
numpy
matplotlib
pandas
tabulate

## FILE: core/__init__.py
# Este archivo está vacío, pero es necesario para que Python reconozca 'core' como un paquete.

## FILE: core/materials.py
# core/materials.py
import math

DEFAULT_ES = 210000.0  # Módulo de Young del acero (MPa) - Usar 200000 o 210000 según norma aplicable

def calculate_ecm_ec2(fck):
    """Calcula el módulo de elasticidad secante del hormigón según EC2 (MPa)."""
    if fck <= 0:
        return 0
    # Fórmula Ecm = 22 * (fcm / 10)^0.3, donde fcm = fck + 8
    fcm = fck + 8
    ecm = 22000 * math.pow(fcm / 10, 0.3)
    return ecm

def get_modular_ratio(fck, Es=DEFAULT_ES):
    """Calcula la relación modular n = Es / Ecm."""
    Ecm = calculate_ecm_ec2(fck)
    if Ecm <= 1e-9: # Evitar división por cero o valores muy pequeños
        # Considerar lanzar un error o devolver infinito/un valor muy grande
        print(f"Advertencia: Ecm calculado es muy bajo ({Ecm:.2f}) para fck={fck}. La relación modular será muy alta.")
        return float('inf')
    return Es / Ecm

## FILE: core/section_analysis.py
# core/section_analysis.py
import numpy as np
# No necesitamos importar get_modular_ratio aquí si se pasa desde fuera

def calculate_section_properties(shapes, homogenize=False, modular_ratio=None):
    """
    Calcula las propiedades geométricas de una colección de formas.
    Si homogenize es True, transforma el HORMIGÓN a ACERO equivalente
    dividiendo sus propiedades (A, Ix, Iy) por modular_ratio (n=Es/Ecm).
    Requiere que modular_ratio sea proporcionado si homogenize es True.

    Args:
        shapes (list): Lista de objetos SteelPlate y ConcreteTrapezoid.
        homogenize (bool): True para realizar la homogeneización a acero.
        modular_ratio (float, optional): Relación modular n = Es / Ecm. Necesario si homogenize=True.

    Returns:
        dict: Diccionario con 'total_area', 'centroid_x', 'centroid_y',
              'inertia_x', 'inertia_y'.

    Raises:
        ValueError: Si se intenta homogeneizar sin un modular_ratio válido.
    """
    if homogenize and modular_ratio is None:
        raise ValueError("Se requiere 'modular_ratio' para homogeneizar.")
    if homogenize and modular_ratio <= 0:
         raise ValueError("'modular_ratio' debe ser positivo para homogeneizar.")

    total_area = 0.0
    moment_x = 0.0  # Sum(Ai * yi)
    moment_y = 0.0  # Sum(Ai * xi)
    inertia_x_global = 0.0 # Sum(Ix_local_i + Ai * dy_i^2)
    inertia_y_global = 0.0 # Sum(Iy_local_i + Ai * dx_i^2)

    processed_shapes = [] # Guardaremos las propiedades (A, x, y, Ix, Iy) de cada parte

    for shape in shapes:
        try:
            A = shape.area
            x = shape.cg_x
            y = shape.cg_y
            Ix_local = shape.inertia_x_local
            # Manejar posible None de Iy_local en Trapecio o si no está implementado
            Iy_local = shape.inertia_y_local if hasattr(shape, 'inertia_y_local') and shape.inertia_y_local is not None else 0.0
        except AttributeError as e:
             raise AttributeError(f"El objeto {type(shape)} no tiene una propiedad necesaria: {e}")


        if homogenize and hasattr(shape, 'material') and shape.material == "concrete":
            # Homogeneizar hormigón a acero dividiendo por n
            # Se asume que Ix e Iy locales escalan con 1/n.
            # (Verificado para Ix, pero Iy puede tener dependencia n^3 para formas como rectángulos)
            # Procedemos con 1/n para ambos por simplicidad inicial, enfocado en Ix.
            if modular_ratio == 0: # Doble chequeo por si acaso
                 raise ValueError("Intento de división por cero en homogeneización (modular_ratio=0).")
            A /= modular_ratio
            Ix_local /= modular_ratio
            Iy_local /= modular_ratio # Precaución con esta simplificación para Iy

        # Las partes de acero no cambian en esta homogeneización
        # else: # shape.material == "steel" or not homogenize
        #     pass # Keep original properties

        # Ignorar formas con área nula o negativa (podría ocurrir con escalas raras)
        if abs(A) > 1e-9: # Usar abs() por si acaso
            processed_shapes.append({'A': A, 'x': x, 'y': y, 'Ix': Ix_local, 'Iy': Iy_local})
            total_area += A
            moment_x += A * y
            moment_y += A * x
        # else: # Opcional: Informar si se ignora una forma
             # print(f"Advertencia: Ignorando forma {type(shape)} con área calculada cercana a cero: {A}")


    if abs(total_area) < 1e-9:
        # Devuelve ceros si el área total es despreciable
        return {'total_area': 0, 'centroid_x': 0, 'centroid_y': 0, 'inertia_x': 0, 'inertia_y': 0}

    # Calcular centroide global
    centroid_x = moment_y / total_area
    centroid_y = moment_x / total_area

    # Calcular inercias globales usando el Teorema de Steiner (Ejes Paralelos)
    for props in processed_shapes:
        dy = props['y'] - centroid_y
        dx = props['x'] - centroid_x
        # Steiner: I_global = Sum( I_local_cg + A * d^2 )
        inertia_x_global += props['Ix'] + props['A'] * dy**2
        inertia_y_global += props['Iy'] + props['A'] * dx**2

    return {
        'total_area': total_area,
        'centroid_x': centroid_x,
        'centroid_y': centroid_y,
        'inertia_x': inertia_x_global, # Inercia respecto al eje X que pasa por el CDG global
        'inertia_y': inertia_y_global  # Inercia respecto al eje Y que pasa por el CDG global
    }

## FILE: shapes/__init__.py
# Este archivo está vacío, pero es necesario para que Python reconozca 'shapes' como un paquete.

## FILE: shapes/steel_plate.py
# shapes/steel_plate.py
import numpy as np

class SteelPlate:
    """Representa una chapa de acero rectangular alineada con los ejes globales X,Y."""
    def __init__(self, width, height, cg_x, cg_y):
        self.width = float(width)   # Dimensión paralela al eje X
        self.height = float(height) # Dimensión paralela al eje Y
        self.cg_x = float(cg_x)
        self.cg_y = float(cg_y)
        self.material = "steel"

        if self.width <= 0 or self.height <= 0:
            raise ValueError("El ancho y alto de la chapa deben ser positivos.")

    @property
    def area(self):
        return self.width * self.height

    @property
    def inertia_x_local(self):
        """Inercia respecto al eje x que pasa por su CDG local (paralelo a X global)."""
        # Eje horizontal por el centroide: b*h^3/12 -> width * height^3 / 12
        return self.width * self.height**3 / 12

    @property
    def inertia_y_local(self):
        """Inercia respecto al eje y que pasa por su CDG local (paralelo a Y global)."""
        # Eje vertical por el centroide: h*b^3/12 -> height * width^3 / 12
        return self.height * self.width**3 / 12

    @property
    def y_min(self):
        return self.cg_y - self.height / 2
    @property
    def y_max(self):
        return self.cg_y + self.height / 2
    @property
    def x_min(self):
        return self.cg_x - self.width / 2
    @property
    def x_max(self):
        return self.cg_x + self.width / 2

    def get_vertices(self, width_scale_factor=1.0):
        """
        Devuelve las coordenadas de los 4 vértices para dibujar.
        El 'width_scale_factor' solo afecta si se quisiera visualizar
        la homogeneización de acero (normalmente no se hace).
        Aquí escala la dimensión 'width' (paralela a X).
        """
        scaled_width = self.width * width_scale_factor
        half_w = scaled_width / 2
        half_h = self.height / 2 # La altura (paralela a Y) no se escala por defecto

        return [
            (self.cg_x - half_w, self.cg_y - half_h), # Bottom-left
            (self.cg_x + half_w, self.cg_y - half_h), # Bottom-right
            (self.cg_x + half_w, self.cg_y + half_h), # Top-right
            (self.cg_x - half_w, self.cg_y + half_h)  # Top-left
        ]

## FILE: shapes/concrete_trapezoid.py
# shapes/concrete_trapezoid.py
import numpy as np

class ConcreteTrapezoid:
    """
    Representa un trapecio de hormigón, definido por anchos inferior/superior,
    altura y coordenadas del centro de la base inferior.
    Se asume simetría vertical respecto al eje que pasa por el centro de la base inferior.
    """
    def __init__(self, bottom_width, top_width, height, bottom_center_x, bottom_center_y):
        self.b1 = float(bottom_width)  # Ancho inferior
        self.b2 = float(top_width)    # Ancho superior
        self.h = float(height)
        self.bc_x = float(bottom_center_x) # X del centro de la base inferior
        self.bc_y = float(bottom_center_y) # Y del centro (y nivel) de la base inferior
        self.material = "concrete"

        if self.h <= 0:
             raise ValueError("La altura del trapecio debe ser positiva.")
        if self.b1 < 0 or self.b2 < 0:
             raise ValueError("Los anchos del trapecio no pueden ser negativos.")

    @property
    def area(self):
        return (self.b1 + self.b2) / 2 * self.h

    @property
    def cg_y_local(self):
        """Distancia vertical del CDG a la base inferior."""
        sum_b = self.b1 + self.b2
        if abs(sum_b) < 1e-9: # Evitar división por cero si el área es 0 (b1=b2=0)
             # Si el área es cero, el CDG está indefinido, pero podemos devolver la mitad de la altura
             # o manejarlo como un caso especial. Devolver h/2 es razonable.
             return self.h / 2
        # Fórmula para la posición Y del Cdg respecto a la base inferior
        return (self.h / 3) * (self.b1 + 2 * self.b2) / sum_b

    @property
    def cg_x(self):
        """Coordenada X global del CDG (asume simetría respecto al eje vertical que pasa por bc_x)."""
        # Para un trapecio isósceles (o definido simétricamente), el CDG está en el eje de simetría
        return self.bc_x

    @property
    def cg_y(self):
        """Coordenada Y global del CDG."""
        return self.bc_y + self.cg_y_local

    @property
    def inertia_x_local(self):
        """Inercia respecto al eje x que pasa por su CDG local (paralelo a X global)."""
        sum_b = self.b1 + self.b2
        if abs(sum_b) < 1e-9:
            return 0 # Inercia cero si el área es cero
        # Fórmula de la inercia de un trapecio respecto a su eje centroidal horizontal
        return (self.h**3 / 36) * (self.b1**2 + 4 * self.b1 * self.b2 + self.b2**2) / sum_b

    @property
    def inertia_y_local(self):
        """Inercia respecto al eje y que pasa por su CDG local (paralelo a Y global, asume simetría)."""
        # Fórmula para trapecio simétrico respecto al eje vertical centroidal
        # Fuente: https://calcresource.com/moment-of-inertia-trap.html (adaptada a ejes centroidales)
        # Iy = (h / 48) * (b1 + b2) * (b1^2 + b2^2) <-- Esta fórmula parece ser respecto a la base, no centroidal
        # La inercia respecto al eje Y centroidal para un trapecio isósceles es más compleja.
        # I_y_centroidal = (h * (b1^3 + b1^2*b2 + b1*b2^2 + b2^3)) / (36 * (b1+b2)) <-- Verificar!
        # Por simplicidad y foco en Ix, devolveremos None o 0. Implementar si es crucial.
        # print("Advertencia: Iy_local para ConcreteTrapezoid no implementada robustamente (asume 0).")
        sum_b = self.b1 + self.b2
        if abs(sum_b) < 1e-9 or self.h == 0:
            return 0.0

        # Fórmula encontrada (verificar fuente): Iy_cg = h * (b1^3 + b2^3 + b1^2*b2 + b1*b2^2) / (12 * (b1+b2)) - A * (dist_eje_sim_a_cg_x)^2
        # Como asumimos simetría (cg_x = bc_x), la distancia es 0.
        # Iy_cg = h * (b1+b2)*(b1^2+b2^2) / 48  <-- Otra fuente (e.g. Amesweb)
        # Usemos la de Amesweb por simplicidad, PERO VERIFICAR si es centroidal o respecto al eje de simetría.
        # Si es respecto al eje de simetría que pasa por bc_x, está bien si cg_x=bc_x.
        try:
            # Esta fórmula SÍ parece corresponder a la inercia respecto al eje Y centroidal para un trapecio ISÓSCELES.
            inertia = (self.h * (self.b1 + self.b2) * (self.b1**2 + self.b2**2)) / 48.0
            return inertia
        except ZeroDivisionError:
            return 0.0
        # return 0.0 # Devolver 0 si no estamos seguros o no es necesaria

    @property
    def y_min(self):
        return self.bc_y
    @property
    def y_max(self):
        return self.bc_y + self.h
    @property
    def x_min(self):
        # El mínimo X está en el borde exterior de la base o el top, el que sea más ancho
        max_half_b = max(self.b1 / 2, self.b2 / 2) if self.b1 >= 0 and self.b2 >= 0 else 0
        return self.bc_x - max_half_b
    @property
    def x_max(self):
        max_half_b = max(self.b1 / 2, self.b2 / 2) if self.b1 >= 0 and self.b2 >= 0 else 0
        return self.bc_x + max_half_b

    def get_vertices(self, width_scale_factor=1.0):
        """
        Devuelve las coordenadas de los 4 vértices para dibujar.
        El 'width_scale_factor' escala los anchos b1 y b2 (usado para visualizar homogeneización).
        """
        scaled_b1 = self.b1 * width_scale_factor
        scaled_b2 = self.b2 * width_scale_factor
        half_b1 = scaled_b1 / 2
        half_b2 = scaled_b2 / 2
        # bc_x es el centro de la base inferior original. El escalado se hace simétrico respecto a él.
        return [
            (self.bc_x - half_b1, self.bc_y),             # Bottom-left
            (self.bc_x + half_b1, self.bc_y),             # Bottom-right
            (self.bc_x + half_b2, self.bc_y + self.h),    # Top-right
            (self.bc_x - half_b2, self.bc_y + self.h)     # Top-left
        ]

## FILE: shapes/rotated_steel_plate.py
# shapes/rotated_steel_plate.py
import numpy as np
import math

class RotatedSteelPlate:
    """
    Representa una chapa de acero rectangular con un espesor, definida por:
    1) Punto inicial, punto final y espesor.
    2) Punto inicial, vector director, longitud y espesor.
    La chapa puede estar rotada en el plano XY.
    """
    def __init__(self, thickness, p1=None, p2=None, vector=None, length=None, definition_method=None):
        """
        Inicializa la chapa rotada.

        Args:
            thickness (float): Espesor de la chapa (será el 'ancho' local).
            p1 (tuple, optional): Coordenadas (x1, y1) del punto inicial. Requerido si no se usa vector/length.
            p2 (tuple, optional): Coordenadas (x2, y2) del punto final. Requerido si no se usa vector/length.
            vector (tuple, optional): Vector director (vx, vy). Usado con p1 y length.
            length (float, optional): Longitud de la chapa. Usado con p1 y vector.
            definition_method (str, optional): Almacena cómo fue definida ('Points' o 'Vector') para la edición.

        Raises:
            ValueError: Si los argumentos de entrada no son suficientes o son inconsistentes.
        """
        self.t = float(thickness)
        self.material = "steel"
        self.definition_method = definition_method # Guardar para la edición

        if self.t <= 0:
             raise ValueError("El espesor de la chapa debe ser positivo.")

        if p1 is None:
            raise ValueError("El punto inicial 'p1' es requerido.")
        self.p1 = np.array(p1, dtype=float)

        if p2 is not None:
            # Definición por p1 y p2
            self.p2 = np.array(p2, dtype=float)
            if vector is not None or length is not None:
                # Permitir pero advertir puede ser peligroso si los datos son inconsistentes.
                # Mejor ser estricto o elegir una prioridad clara.
                # print("Advertencia: Se proporcionaron p1/p2 y vector/length. Se usarán p1 y p2.")
                pass # Ignorar vector/length si se dan p1 y p2
            diff = self.p2 - self.p1
            self.L = np.linalg.norm(diff)
            if self.L < 1e-9:
                raise ValueError("Los puntos p1 y p2 son coincidentes (longitud cero).")
            # Vector director unitario
            self.u_dir = diff / self.L
            # Calcular vector y longitud originales para posible edición
            self._vector_original = tuple(diff) # Guardar vector no unitario
            self._length_original = self.L # Guardar longitud
            if not self.definition_method: self.definition_method = 'Points'

        elif vector is not None and length is not None:
            # Definición por p1, vector y length
            self.L = float(length)
            if self.L <= 0:
                raise ValueError("La longitud 'length' debe ser positiva.")
            v = np.array(vector, dtype=float)
            v_norm = np.linalg.norm(v)
            if v_norm < 1e-9:
                raise ValueError("El vector director no puede ser cero.")
            # Vector director unitario
            self.u_dir = v / v_norm
            self.p2 = self.p1 + self.L * self.u_dir
             # Guardar vector y longitud originales para posible edición
            self._vector_original = tuple(v)
            self._length_original = self.L
            if not self.definition_method: self.definition_method = 'Vector'
        else:
            raise ValueError("Debe proporcionar 'p2' o ('vector' y 'length').")

        # Calcular ángulo con el eje X global (en radianes)
        self.theta = math.atan2(self.u_dir[1], self.u_dir[0])

        # Calcular centro de gravedad (punto medio del eje longitudinal)
        self.cg_x = (self.p1[0] + self.p2[0]) / 2
        self.cg_y = (self.p1[1] + self.p2[1]) / 2

    @property
    def area(self):
        """Área de la chapa."""
        return self.L * self.t

    # --- Propiedades de Inercia ---
    # Calculamos Ix e Iy respecto a ejes paralelos a los globales X,Y
    # pero que pasan por el CDG de la chapa.

    @property
    def inertia_x_local(self):
        """Inercia respecto a eje X' // X global, pasando por CDG local."""
        # Iu = Inercia sobre eje longitudinal (u) = t * L^3 / 12
        # Iv = Inercia sobre eje transversal (v) = L * t^3 / 12
        # Nota: 'u' es el eje a lo largo de L, 'v' es el eje a lo largo de t.
        Iu = self.t * self.L**3 / 12
        Iv = self.L * self.t**3 / 12
        sin_t = math.sin(self.theta)
        cos_t = math.cos(self.theta)
        # Fórmula de rotación de tensor de inercia:
        # Ix_cg = (Iu+Iv)/2 + (Iu-Iv)/2 * cos(2*theta) <-- Incorrecto para ejes X,Y
        # Usando transformación directa: Ix_cg = Iu*sin^2(theta) + Iv*cos^2(theta)
        return Iu * sin_t**2 + Iv * cos_t**2

    @property
    def inertia_y_local(self):
        """Inercia respecto a eje Y' // Y global, pasando por CDG local."""
        Iu = self.t * self.L**3 / 12
        Iv = self.L * self.t**3 / 12
        sin_t = math.sin(self.theta)
        cos_t = math.cos(self.theta)
        # Iy_cg = Iu*cos^2(theta) + Iv*sin^2(theta)
        return Iu * cos_t**2 + Iv * sin_t**2

    # @property
    # def inertia_xy_local(self):
    #     """Producto de inercia respecto a ejes X', Y' // globales por CDG."""
    #     # Ixy_cg = (Iu - Iv) * sin(theta) * cos(theta)
    #     Iu = self.t * self.L**3 / 12
    #     Iv = self.L * self.t**3 / 12
    #     sin_t = math.sin(self.theta)
    #     cos_t = math.cos(self.theta)
    #     return (Iu - Iv) * sin_t * cos_t
        # NOTA: La función de análisis de sección actual no usa Ixy_local.

    def get_vertices(self, width_scale_factor=1.0):
        """
        Devuelve las coordenadas de los 4 vértices de la chapa rectangular.
        El 'width_scale_factor' escala el espesor (t).
        """
        scaled_t = self.t * width_scale_factor
        if scaled_t < 0: scaled_t = 0 # Evitar espesor negativo
        half_t = scaled_t / 2

        # Vector normal (perpendicular a u_dir, longitud 1)
        # Rotar u_dir 90 grados: (x, y) -> (-y, x)
        u_norm = np.array([-self.u_dir[1], self.u_dir[0]])

        # Calcular los 4 vértices usando p1, p2 y el vector normal escalado
        v1 = self.p1 + half_t * u_norm
        v2 = self.p2 + half_t * u_norm
        v3 = self.p2 - half_t * u_norm
        v4 = self.p1 - half_t * u_norm

        # Devolver como lista de tuplas
        return [tuple(v1), tuple(v2), tuple(v3), tuple(v4)]

    # Propiedades para límites bounding box (calculadas a partir de vértices)
    @property
    def _vertices_coords(self):
        """Helper para no recalcular vértices innecesariamente."""
        # Podríamos cachear esto si fuera costoso, pero por ahora lo recalculamos
        return self.get_vertices() # Llama al método existente con factor 1.0

    @property
    def y_min(self):
        return min(v[1] for v in self._vertices_coords)
    @property
    def y_max(self):
        return max(v[1] for v in self._vertices_coords)
    @property
    def x_min(self):
        return min(v[0] for v in self._vertices_coords)
    @property
    def x_max(self):
        return max(v[0] for v in self._vertices_coords)

## FILE: visualization/__init__.py
# Este archivo está vacío, pero es necesario para que Python reconozca 'visualization' como un paquete.

## FILE: visualization/plot_section.py
# visualization/plot_section.py
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
import math

def plot_section(shapes, title="Sección Transversal", highlight_centroid=None, centroid_label="CDG",
                 homogenize_visual=False, modular_ratio=None,
                 xlims=None, ylims=None): # <-- NUEVOS ARGUMENTOS
    """
    Dibuja la sección transversal usando Matplotlib.
    Puede dibujar la sección original o una visualización homogeneizada (Hormigón->Acero).
    Permite especificar límites de ejes para consistencia entre plots.

    Args:
        # ... (argumentos anteriores) ...
        xlims (tuple, optional): Tupla (min_x, max_x) para los límites del eje X.
        ylims (tuple, optional): Tupla (min_y, max_y) para los límites del eje Y.
    """
    if homogenize_visual and (modular_ratio is None or modular_ratio <= 0):
        # Manejar caso inválido, quizás dibujando la original o mostrando error
        print(f"Advertencia: modular_ratio inválido ({modular_ratio}) para visualización homogeneizada. Dibujando original.")
        homogenize_visual = False # Dibujar la original como fallback
        # O podríamos lanzar un error:
        # raise ValueError("Se requiere 'modular_ratio' positivo para la visualización homogeneizada.")


    # Reducir figsize para que los gráficos sean más pequeños
    fig, ax = plt.subplots(figsize=(6, 6)) # <- Tamaño ajustado

    all_vertices_plot = [] # Vértices usados para este plot específico (para auto-escala si no se dan límites)
    legend_handles = {} # Para evitar leyendas duplicadas

    for shape in shapes:
        scale_factor = 1.0
        color = 'grey' # Default color
        hatch = None   # Default hatch
        base_label = "Desconocido" # Default label

        # Determinar estilo basado en material y si se visualiza homogeneización
        is_concrete = hasattr(shape, 'material') and shape.material == "concrete"
        is_steel = hasattr(shape, 'material') and shape.material == "steel"

        label_suffix = ""
        if is_steel:
             color = 'lightblue'
             hatch = '//'
             base_label = 'Acero'
        elif is_concrete:
             color = 'lightgrey'
             hatch = '..'
             base_label = 'Hormigón'
             if homogenize_visual:
                 # Asegurarse de que modular_ratio es válido antes de dividir
                 if modular_ratio is not None and modular_ratio > 0:
                     scale_factor = 1.0 / modular_ratio
                 else:
                     scale_factor = 1.0 # O manejar error
                 # Cambiar estilo para hormigón homogeneizado visualmente
                 color = 'lightcoral' # Diferente color
                 hatch = 'xx'
                 label_suffix = f' (Ancho/{modular_ratio:.2f})' if modular_ratio else ' (Error Ratio)'


        # Obtener vértices (escalados si es necesario para este plot)
        try:
            vertices = shape.get_vertices(width_scale_factor=scale_factor)
            all_vertices_plot.extend(vertices) # Añadir a la lista de este plot
        except TypeError: # Si get_vertices no acepta el argumento (clases antiguas?)
             print(f"Advertencia: {type(shape)}.get_vertices no acepta width_scale_factor. Usando factor 1.0.")
             vertices = shape.get_vertices()
             all_vertices_plot.extend(vertices)
        except Exception as e:
            print(f"Error obteniendo vértices para {type(shape)}: {e}. Saltando forma.")
            continue # Saltar esta forma si no se pueden obtener los vértices


        # Dibujar el polígono
        final_label = f"{base_label}{label_suffix}"
        # closed=True es el default para Polygon, pero lo ponemos explícito
        poly = patches.Polygon(vertices, closed=True, facecolor=color, edgecolor='black', hatch=hatch)
        ax.add_patch(poly)

        # Añadir a leyenda si es la primera vez que vemos este tipo/material/estado
        if final_label not in legend_handles:
             legend_handles[final_label] = poly # Guardar el patch para la leyenda

        # Anotar CDG original de la parte (siempre sobre la geometría original, si no es visualización homog.)
        # y si la forma tiene las propiedades cg_x, cg_y
        if not homogenize_visual and hasattr(shape, 'cg_x') and hasattr(shape, 'cg_y'):
             try:
                 ax.plot(shape.cg_x, shape.cg_y, 'ko', markersize=3, label='_nolegend_') # k=black, o=circle, no en leyenda
             except Exception as e:
                 print(f"Advertencia: No se pudo dibujar CDG para {type(shape)}: {e}")


    # --- Configurar límites y aspecto del gráfico ---

    # Usar límites proporcionados si existen
    if xlims is not None:
        ax.set_xlim(xlims)
    elif all_vertices_plot: # Auto-escala X si no se proporcionan límites y hay vértices
        all_x = [v[0] for v in all_vertices_plot]
        min_x, max_x = min(all_x), max(all_x)
        delta_x = max(max_x - min_x, 10)
        margin_x = delta_x * 0.15 + 10 # Margen ajustado
        ax.set_xlim(min_x - margin_x, max_x + margin_x)
    else:
        ax.set_xlim(-100, 100) # Default si no hay vértices ni límites

    if ylims is not None:
        ax.set_ylim(ylims)
    elif all_vertices_plot: # Auto-escala Y si no se proporcionan límites y hay vértices
        all_y = [v[1] for v in all_vertices_plot]
        min_y, max_y = min(all_y), max(all_y)
        delta_y = max(max_y - min_y, 10)
        margin_y = delta_y * 0.15 + 10 # Margen ajustado
        ax.set_ylim(min_y - margin_y, max_y + margin_y)
    else:
        ax.set_ylim(-100, 100) # Default

    # Dibujar centroide global resaltado si se proporciona
    if highlight_centroid and isinstance(highlight_centroid, dict) and 'x' in highlight_centroid and 'y' in highlight_centroid:
        try:
            cx, cy = highlight_centroid['x'], highlight_centroid['y']
            # Usar un marcador distinto y color llamativo
            marker_style = 'X' # 'X' o 'P' (plus) son visibles
            marker_color = 'red'
            marker_size = 8 # Reducir tamaño ligeramente
            marker = ax.plot(cx, cy, marker=marker_style, color=marker_color, markersize=marker_size, linestyle='None', label=centroid_label)[0]
            # Añadir texto cerca del marcador
            ax.text(cx, cy, f'  {centroid_label}', color=marker_color, va='bottom', ha='left', fontsize=8, fontweight='bold') # Fuente más pequeña
            # Añadir a la leyenda si no estaba ya (poco probable con etiqueta única)
            if centroid_label not in legend_handles:
                 legend_handles[centroid_label] = marker
        except Exception as e:
            print(f"Advertencia: No se pudo dibujar el centroide resaltado ({centroid_label}): {e}")


    # Configuración final del plot
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlabel("Coordenada X (mm)")
    ax.set_ylabel("Coordenada Y (mm)")
    ax.set_title(title, fontsize=10, fontweight='bold') # Fuente más pequeña para el título
    ax.grid(True, linestyle=':', linewidth=0.5, color='gray', alpha=0.7) # Estilo de rejilla más sutil
    # Crear leyenda única a partir de los handles guardados
    if legend_handles:
         ax.legend(legend_handles.values(), legend_handles.keys(), loc='best', fontsize=8) # Leyenda más pequeña

    # Devolver la figura de matplotlib
    return fig

## FILE: main_app.py
# main_app.py
import streamlit as st
import pandas as pd
import numpy as np
import math # Necesario para RotatedSteelPlate
import locale # Para formato de fecha
from datetime import datetime # Para fecha

# Importaciones (asumiendo estructura de carpetas correcta)
# Intentar importaciones relativas si se ejecuta como módulo, si no, directas.
try:
    from .core.materials import calculate_ecm_ec2, get_modular_ratio, DEFAULT_ES
    from .core.section_analysis import calculate_section_properties
    from .shapes.steel_plate import SteelPlate # Chapa original (alineada con ejes)
    from .shapes.concrete_trapezoid import ConcreteTrapezoid
    from .shapes.rotated_steel_plate import RotatedSteelPlate # ¡Nueva clase!
    from .visualization.plot_section import plot_section
except ImportError:
    # Fallback si se ejecuta como script simple (streamlit run main_app.py)
    from core.materials import calculate_ecm_ec2, get_modular_ratio, DEFAULT_ES
    from core.section_analysis import calculate_section_properties
    from shapes.steel_plate import SteelPlate # Chapa original (alineada con ejes)
    from shapes.concrete_trapezoid import ConcreteTrapezoid
    from shapes.rotated_steel_plate import RotatedSteelPlate # ¡Nueva clase!
    from visualization.plot_section import plot_section


# Configuración de la página de Streamlit
st.set_page_config(
    page_title="Análisis de Secciones Mixtas",
    page_icon="🏗️",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- Estado de la Sesión ---
# Inicializar listas de formas si no existen
if 'shapes' not in st.session_state:
    st.session_state.shapes = []
if 'undo_stack' not in st.session_state:
     st.session_state.undo_stack = [] # Para posible función de deshacer
# Inicializar estado de edición si no existe
if 'editing_index' not in st.session_state:
     st.session_state.editing_index = None


# --- Funciones Auxiliares ---
def add_shape(shape_object):
    """Añade una forma a la lista y guarda el estado anterior para deshacer."""
    # Guardar estado actual antes de añadir
    current_shapes_copy = [s for s in st.session_state.shapes] # Copia superficial es suficiente
    st.session_state.undo_stack.append(current_shapes_copy)
    # Limitar tamaño del historial de deshacer (opcional)
    max_undo = 10
    if len(st.session_state.undo_stack) > max_undo:
         st.session_state.undo_stack.pop(0) # Eliminar el más antiguo

    # Añadir la nueva forma
    st.session_state.shapes.append(shape_object)

def update_shape(index, updated_shape_object):
    """Actualiza una forma en la lista y guarda el estado anterior para deshacer."""
    if 0 <= index < len(st.session_state.shapes):
        # Guardar estado actual antes de actualizar
        current_shapes_copy = [s for s in st.session_state.shapes]
        st.session_state.undo_stack.append(current_shapes_copy)
        max_undo = 10
        if len(st.session_state.undo_stack) > max_undo: st.session_state.undo_stack.pop(0)

        # Actualizar la forma
        st.session_state.shapes[index] = updated_shape_object
    else:
        st.error(f"Índice de edición {index} fuera de rango.")


def delete_shape(index):
    """Elimina una forma de la lista y guarda el estado anterior para deshacer."""
    if 0 <= index < len(st.session_state.shapes):
        # Guardar estado actual antes de borrar
        current_shapes_copy = [s for s in st.session_state.shapes]
        st.session_state.undo_stack.append(current_shapes_copy)
        max_undo = 10
        if len(st.session_state.undo_stack) > max_undo: st.session_state.undo_stack.pop(0)

        # Eliminar la forma
        st.session_state.shapes.pop(index)
        return True # Indicar éxito
    else:
        st.error(f"Índice de borrado {index} fuera de rango.")
        return False # Indicar fallo


def undo_last_action():
    """Restaura el estado anterior de las formas."""
    if st.session_state.undo_stack:
        previous_shapes = st.session_state.undo_stack.pop()
        st.session_state.shapes = previous_shapes
        # Si estábamos editando, cancelar la edición al deshacer
        st.session_state.editing_index = None
        st.success("Última acción deshecha.")
        st.rerun() # Forzar actualización de la UI
    else:
        st.warning("No hay acciones que deshacer.")

# --- Interfaz Principal ---
st.title("📊 Analizador de Propiedades de Secciones Mixtas")
st.write("Herramienta para calcular propiedades geométricas de secciones compuestas Hormigón-Acero.")
st.write("*(Homogeneización: Hormigón transformado a Acero equivalente)*")


# --- Columnas para layout ---
col_input, col_results = st.columns([1, 1.5]) # Dar más espacio a resultados/plots

# --- Columna de Entrada ---
with col_input:
    st.header("🏗️ Definición de la Sección")

    # --- Materiales ---
    with st.container(border=True): # Agrupar visualmente
        st.subheader("GPa | Materiales")
        c1, c2 = st.columns(2)
        with c1:
            fck = st.number_input(
                "Hormigón, $f_{ck}$ (MPa)",
                min_value=12.0, max_value=90.0, value=30.0, step=1.0,
                help="Resistencia característica del hormigón a compresión."
            )
        with c2:
            Es = st.number_input(
                "Acero, $E_s$ (MPa)",
                value=DEFAULT_ES, format="%f", step=1000.0,
                help="Módulo de elasticidad del acero estructural."
            )

        # Calcular y mostrar propiedades derivadas
        n_display = "N/A" # Valor por defecto para mostrar
        try:
            n = get_modular_ratio(fck, Es) # n = Es / Ecm
            if n == float('inf') or n <= 0:
                 st.error(f"Relación modular n inválida ({n:.2f}). Verifique fck.")
                 Ecm = 0
                 n_display = "Inválido"
            else:
                 Ecm = Es / n
                 st.info(f"$E_{{cm}} = {Ecm:.1f}$ MPa | $n = E_s / E_{{cm}} = {n:.2f}$")
                 n_display = f"{n:.2f}"
        except Exception as e:
            st.error(f"Error calculando propiedades de materiales: {e}")
            n = 0 # Valor inválido para evitar cálculos posteriores
            n_display = "Error"

    # --- Geometría (Añadir / Editar Componentes) ---
    st.subheader("📐 Geometría")

    # Determinar si estamos en modo edición y qué tipo de forma
    editing_mode = st.session_state.editing_index is not None
    shape_being_edited = None
    shape_type_being_edited = None
    if editing_mode:
         try:
             shape_being_edited = st.session_state.shapes[st.session_state.editing_index]
             shape_type_being_edited = type(shape_being_edited)
             st.info(f"✏️ Editando Componente #{st.session_state.editing_index + 1} ({shape_type_being_edited.__name__}). Modifica los valores abajo y guarda.")
         except IndexError:
              st.error("Error: Índice de edición no válido. Cancelando edición.")
              st.session_state.editing_index = None
              editing_mode = False


    # Crear pestañas para los formularios
    # Deshabilitar otras pestañas mientras se edita podría ser una opción (más complejo)
    tab_aligned, tab_rotated, tab_concrete = st.tabs(["Chapa Alineada", "Chapa Rotada", "Hormigón Trapecio"])

    # --- Formulario Chapa Acero (alineada con ejes) ---
    with tab_aligned:
        editing_this_type = editing_mode and shape_type_being_edited == SteelPlate
        default_values_aligned = {}
        if editing_this_type:
            default_values_aligned = {
                "s_w_aligned": shape_being_edited.width,
                "s_h_aligned": shape_being_edited.height,
                "s_x_aligned": shape_being_edited.cg_x,
                "s_y_aligned": shape_being_edited.cg_y,
            }

        with st.form("steel_form_aligned", clear_on_submit=False, border=False): # clear_on_submit=False para editar
            st.write("**Chapa rectangular alineada con ejes X, Y.**")
            c1, c2 = st.columns(2)
            s_width = c1.number_input("Ancho (en X) [mm]", min_value=0.1,
                                       value=default_values_aligned.get("s_w_aligned", 100.0), key="s_w_aligned_input")
            s_height = c2.number_input("Alto (en Y) [mm]", min_value=0.1,
                                        value=default_values_aligned.get("s_h_aligned", 10.0), key="s_h_aligned_input")
            c1, c2 = st.columns(2)
            s_cg_x = c1.number_input("Coord. X del CDG [mm]", format="%f",
                                       value=default_values_aligned.get("s_x_aligned", 0.0), key="s_x_aligned_input")
            s_cg_y = c2.number_input("Coord. Y del CDG [mm]", format="%f",
                                       value=default_values_aligned.get("s_y_aligned", 0.0), key="s_y_aligned_input")

            submit_label = "💾 Guardar Cambios" if editing_this_type else "➕ Añadir Chapa Alineada"
            col_submit, col_cancel = st.columns([0.7, 0.3])
            # Deshabilitar botón si estamos editando OTRO tipo de forma
            disabled_submit = editing_mode and not editing_this_type
            submitted = col_submit.form_submit_button(submit_label, use_container_width=True, disabled=disabled_submit)

            if editing_this_type:
                 if col_cancel.form_submit_button("❌ Cancelar", type="secondary", use_container_width=True):
                      st.session_state.editing_index = None
                      st.warning("Edición cancelada.")
                      st.rerun()
            # Lógica de submit
            if submitted:
                try:
                    new_or_updated_plate = SteelPlate(s_width, s_height, s_cg_x, s_cg_y)
                    if editing_this_type:
                        update_shape(st.session_state.editing_index, new_or_updated_plate) # Usar función auxiliar
                        st.success(f"Componente #{st.session_state.editing_index + 1} actualizado.")
                        st.session_state.editing_index = None # Salir del modo edición
                    else:
                        add_shape(new_or_updated_plate) # Añadir nuevo
                        st.success("Chapa de acero alineada añadida.")
                    st.rerun() # Actualizar UI
                except ValueError as ve: st.error(f"Error: {ve}")
                except Exception as e: st.error(f"Error inesperado: {e}")

    # --- Formulario Chapa Acero Rotada ---
    with tab_rotated:
        editing_this_type_rotated = editing_mode and shape_type_being_edited == RotatedSteelPlate
        default_values_rotated = {}
        initial_def_method_idx = 0 # Default para añadir ('Punto Inicial y Final')
        if editing_this_type_rotated:
            default_values_rotated = {
                "rot_t": shape_being_edited.t,
                "rot_p1x": shape_being_edited.p1[0],
                "rot_p1y": shape_being_edited.p1[1],
                "rot_p2x": shape_being_edited.p2[0],
                "rot_p2y": shape_being_edited.p2[1],
                "rot_vx": shape_being_edited._vector_original[0] if hasattr(shape_being_edited,'_vector_original') else 1.0,
                "rot_vy": shape_being_edited._vector_original[1] if hasattr(shape_being_edited,'_vector_original') else 0.0,
                "rot_l": shape_being_edited._length_original if hasattr(shape_being_edited,'_length_original') else 100.0,
            }
            initial_def_method_idx = 1 if shape_being_edited.definition_method == 'Vector' else 0

        with st.form("steel_form_rotated", clear_on_submit=False, border=False):
            st.write("**Chapa rectangular con orientación genérica.**")
            rot_t = st.number_input("Espesor [mm]", min_value=0.1,
                                     value=default_values_rotated.get("rot_t", 10.0), key="rot_t_input")

            definition_method = st.radio(
                "Definir por:",
                ('Punto Inicial y Final', 'Punto Inicial, Vector y Longitud'),
                key="rot_method_input", horizontal=True,
                index=initial_def_method_idx # Establecer basado en modo edición
            )

            c1, c2 = st.columns(2)
            rot_p1_x = c1.number_input("P1 - Coord. X [mm]", format="%f",
                                       value=default_values_rotated.get("rot_p1x", 0.0), key="rot_p1x_input")
            rot_p1_y = c2.number_input("P1 - Coord. Y [mm]", format="%f",
                                       value=default_values_rotated.get("rot_p1y", 0.0), key="rot_p1y_input")

            if definition_method == 'Punto Inicial y Final':
                c1, c2 = st.columns(2)
                rot_p2_x = c1.number_input("P2 - Coord. X [mm]", format="%f",
                                           value=default_values_rotated.get("rot_p2x", 100.0), key="rot_p2x_input")
                rot_p2_y = c2.number_input("P2 - Coord. Y [mm]", format="%f",
                                           value=default_values_rotated.get("rot_p2y", 0.0), key="rot_p2y_input")
                rot_vector_x, rot_vector_y, rot_length = None, None, None
            else: # 'Punto Inicial, Vector y Longitud'
                c1, c2, c3 = st.columns(3)
                rot_vector_x = c1.number_input("Vector X", format="%f",
                                               value=default_values_rotated.get("rot_vx", 1.0), key="rot_vx_input")
                rot_vector_y = c2.number_input("Vector Y", format="%f",
                                               value=default_values_rotated.get("rot_vy", 0.0), key="rot_vy_input")
                rot_length = c3.number_input("Longitud [mm]", min_value=0.1, format="%f",
                                             value=default_values_rotated.get("rot_l", 100.0), key="rot_l_input")
                rot_p2_x, rot_p2_y = None, None

            submit_label_rotated = "💾 Guardar Cambios" if editing_this_type_rotated else "➕ Añadir Chapa Rotada"
            col_submit_rot, col_cancel_rot = st.columns([0.7, 0.3])
            disabled_submit_rot = editing_mode and not editing_this_type_rotated
            submitted_rotated = col_submit_rot.form_submit_button(submit_label_rotated, use_container_width=True, disabled=disabled_submit_rot)

            if editing_this_type_rotated:
                 if col_cancel_rot.form_submit_button("❌ Cancelar", type="secondary", use_container_width=True, key="cancel_rot"):
                      st.session_state.editing_index = None
                      st.warning("Edición cancelada.")
                      st.rerun()

            if submitted_rotated:
                current_def_method = 'Points' if definition_method == 'Punto Inicial y Final' else 'Vector'
                try:
                    if current_def_method == 'Points':
                        new_or_updated_rotated_plate = RotatedSteelPlate(
                            thickness=rot_t, p1=(rot_p1_x, rot_p1_y), p2=(rot_p2_x, rot_p2_y),
                            definition_method='Points'
                        )
                    else:
                        new_or_updated_rotated_plate = RotatedSteelPlate(
                            thickness=rot_t, p1=(rot_p1_x, rot_p1_y), vector=(rot_vector_x, rot_vector_y), length=rot_length,
                            definition_method='Vector'
                        )

                    if editing_this_type_rotated:
                        update_shape(st.session_state.editing_index, new_or_updated_rotated_plate)
                        st.success(f"Componente #{st.session_state.editing_index + 1} actualizado.")
                        st.session_state.editing_index = None
                    else:
                        add_shape(new_or_updated_rotated_plate)
                        st.success("Chapa de acero rotada añadida.")
                    st.rerun()
                except ValueError as ve: st.error(f"Error: {ve}")
                except Exception as e: st.error(f"Error inesperado: {e}")

    # --- Formulario Trapecio Hormigón ---
    with tab_concrete:
        editing_this_type_concrete = editing_mode and shape_type_being_edited == ConcreteTrapezoid
        default_values_concrete = {}
        if editing_this_type_concrete:
            default_values_concrete = {
                "c_b1": shape_being_edited.b1,
                "c_b2": shape_being_edited.b2,
                "c_h": shape_being_edited.h,
                "c_bx": shape_being_edited.bc_x,
                "c_by": shape_being_edited.bc_y,
            }

        with st.form("concrete_form", clear_on_submit=False, border=False):
            st.write("**Trapecio de hormigón (simétrico).**")
            c1, c2 = st.columns(2)
            c_b1 = c1.number_input("Ancho inferior, b1 [mm]", min_value=0.0, format="%f",
                                   value=default_values_concrete.get("c_b1", 300.0), key="c_b1_input")
            c_b2 = c2.number_input("Ancho superior, b2 [mm]", min_value=0.0, format="%f",
                                   value=default_values_concrete.get("c_b2", 300.0), key="c_b2_input")
            c1, c2 = st.columns(2)
            c_h = c1.number_input("Altura, h [mm]", min_value=0.1, format="%f",
                                  value=default_values_concrete.get("c_h", 200.0), key="c_h_input")
            c1, c2 = st.columns(2)
            c_bc_x = c1.number_input("X centro base inf. [mm]", format="%f",
                                     value=default_values_concrete.get("c_bx", 0.0), key="c_bx_input")
            c_bc_y = c2.number_input("Y centro base inf. [mm]", format="%f",
                                     value=default_values_concrete.get("c_by", 0.0), key="c_by_input")

            submit_label_concrete = "💾 Guardar Cambios" if editing_this_type_concrete else "➕ Añadir Trapecio"
            col_submit_conc, col_cancel_conc = st.columns([0.7, 0.3])
            disabled_submit_conc = editing_mode and not editing_this_type_concrete
            submitted_concrete = col_submit_conc.form_submit_button(submit_label_concrete, use_container_width=True, disabled=disabled_submit_conc)

            if editing_this_type_concrete:
                 if col_cancel_conc.form_submit_button("❌ Cancelar", type="secondary", use_container_width=True, key="cancel_conc"):
                      st.session_state.editing_index = None
                      st.warning("Edición cancelada.")
                      st.rerun()

            if submitted_concrete:
                try:
                    new_or_updated_trapezoid = ConcreteTrapezoid(c_b1, c_b2, c_h, c_bc_x, c_bc_y)
                    if editing_this_type_concrete:
                        update_shape(st.session_state.editing_index, new_or_updated_trapezoid)
                        st.success(f"Componente #{st.session_state.editing_index + 1} actualizado.")
                        st.session_state.editing_index = None
                    else:
                        add_shape(new_or_updated_trapezoid)
                        st.success("Trapecio de hormigón añadido.")
                    st.rerun()
                except ValueError as ve: st.error(f"Error: {ve}")
                except Exception as e: st.error(f"Error inesperado: {e}")


    # --- Lista de Componentes Añadidos (Modificada para edición) ---
    st.subheader("🧩 Componentes Actuales")
    if not st.session_state.shapes:
        st.info("Añade componentes usando las pestañas de arriba.")
    else:
        # Usamos un contenedor con altura fija y scroll si hay muchos elementos
        with st.container(height=300, border=True):
            indices_a_borrar = []

            for i, shape in enumerate(st.session_state.shapes):
                # Crear 3 columnas: Descripción | Editar | Borrar
                col1, col_edit, col_del = st.columns([0.8, 0.1, 0.1])

                shape_desc = f"**{i+1}:** "
                try:
                    # Formatear descripción básica
                    if isinstance(shape, SteelPlate):
                         shape_desc += f"Chapa Alineada [A={shape.width:.1f}, H={shape.height:.1f}]"
                    elif isinstance(shape, RotatedSteelPlate):
                         shape_desc += f"Chapa Rotada [L={shape.L:.1f}, t={shape.t:.1f}, θ={math.degrees(shape.theta):.1f}°]"
                    elif isinstance(shape, ConcreteTrapezoid):
                         shape_desc += f"Trapecio [b1={shape.b1:.1f}, b2={shape.b2:.1f}, h={shape.h:.1f}]"
                    else:
                         shape_desc += f"Tipo {type(shape).__name__}"

                    # Añadir cotas Y min/max (si existen)
                    if hasattr(shape, 'y_min') and hasattr(shape, 'y_max'):
                         shape_desc += f" *(Y: {shape.y_min:.1f} a {shape.y_max:.1f})*"
                    else: # Fallback
                         shape_desc += " *(Cotas Y no disp.)*"

                except Exception as e:
                     shape_desc += f" Error al describir forma: {e}"

                col1.write(shape_desc)

                # Botón Editar: activa el modo edición para este índice
                # Deshabilitar si ya estamos editando OTRO índice
                edit_disabled = editing_mode and st.session_state.editing_index != i
                if col_edit.button("✏️", key=f"edit_{i}", help="Editar este componente", disabled=edit_disabled):
                    st.session_state.editing_index = i
                    st.rerun() # Rerun para que los formularios se actualicen

                # Botón Borrar
                delete_disabled = editing_mode # Deshabilitar borrar mientras se edita? Opcional.
                if col_del.button("🗑️", key=f"del_{i}", help="Eliminar este componente", disabled=delete_disabled):
                     indices_a_borrar.append(i)

            # --- Lógica de Borrado (fuera del bucle) ---
            if indices_a_borrar:
                # Borrar en orden inverso
                indices_borrados_ok = 0
                for index in sorted(indices_a_borrar, reverse=True):
                    if delete_shape(index): # Usar función auxiliar con undo
                         indices_borrados_ok += 1
                         # Si borramos el ítem que se estaba editando, cancelar edición
                         if editing_mode and st.session_state.editing_index == index:
                              st.session_state.editing_index = None
                         # Ajustar índice de edición si borramos uno anterior
                         elif editing_mode and index < st.session_state.editing_index:
                              st.session_state.editing_index -= 1

                st.success(f"Eliminado(s) {indices_borrados_ok} componente(s).")
                st.rerun()

        # --- Botón Apilar Chapa (fuera del container de la lista) ---
        if st.session_state.shapes and not editing_mode: # No mostrar si estamos editando
             last_shape = st.session_state.shapes[-1]
             # Solo permitir apilar sobre chapas
             can_stack = isinstance(last_shape, SteelPlate) or isinstance(last_shape, RotatedSteelPlate)
             if can_stack:
                 if st.button("➕ Apilar Chapa Encima", key="stack_plate", help="Añade una chapa sobre la última chapa añadida."):
                     try:
                         y_max_last = last_shape.y_max
                         if isinstance(last_shape, SteelPlate):
                             new_height = last_shape.height
                             new_cg_y = y_max_last + new_height / 2
                             new_plate_stacked = SteelPlate(width=last_shape.width, height=new_height, cg_x=last_shape.cg_x, cg_y=new_cg_y)
                             add_shape(new_plate_stacked)
                             st.success("Chapa alineada apilada.")
                             st.rerun()
                         elif isinstance(last_shape, RotatedSteelPlate):
                              st.warning("Apilar sobre chapa rotada: Se añadirá una chapa *alineada* con mismo X y espesor/ancho.")
                              new_height = 10.0 # Alto por defecto
                              new_width = last_shape.t
                              new_cg_y = y_max_last + new_height / 2
                              new_plate_stacked = SteelPlate(width=new_width, height=new_height, cg_x=last_shape.cg_x, cg_y=new_cg_y)
                              add_shape(new_plate_stacked)
                              st.success("Chapa alineada apilada sobre rotada.")
                              st.rerun()
                     except AttributeError as ae: st.error(f"Error al apilar: {ae}.")
                     except Exception as e: st.error(f"Error inesperado al apilar: {e}")


    # Botón de deshacer
    if st.session_state.undo_stack:
         # Colocarlo fuera del container de la lista, pero aún en la columna de input
         if st.button("↩️ Deshacer Último Cambio", use_container_width=True):
              undo_last_action() # Ya incluye rerun y limpiar edición


# --- Columna de Resultados (Ajustada con cálculo de límites) ---
with col_results:
    st.header("📊 Resultados del Análisis")

    if st.session_state.shapes and n > 0:
        try:
            # Calcular propiedades originales y homogeneizadas (sin cambios)
            props_orig = calculate_section_properties(st.session_state.shapes, homogenize=False)
            props_homog = calculate_section_properties(st.session_state.shapes, homogenize=True, modular_ratio=n)

            # Mostrar tabla de resultados
            st.subheader("📈 Propiedades Geométricas")
            def format_num(value, precision=2, is_area=False, is_inertia=False):
                try:
                    num = float(value)
                    if is_inertia: return f"{num:,.{precision}e} mm⁴"
                    unit = " mm²" if is_area else " mm"
                    return f"{num:,.{precision}f}{unit}"
                except: return str(value) if value is not None else "Error"
            data = {
                'Propiedad': ['Área Total (A)', 'Centroide X (Xg)', 'Centroide Y (Yg)', 'Inercia Ix (CDG)', 'Inercia Iy (CDG)'],
                'Sección Original': [
                    format_num(props_orig['total_area'], precision=1, is_area=True), format_num(props_orig['centroid_x']), format_num(props_orig['centroid_y']),
                    format_num(props_orig.get('inertia_x'), precision=3, is_inertia=True) if props_orig.get('inertia_x') else "N/A",
                    format_num(props_orig.get('inertia_y'), precision=3, is_inertia=True) if props_orig.get('inertia_y') else "N/A"
                ],
                'Sección Homogeneizada (a Acero)': [
                    f"{format_num(props_homog['total_area'], precision=1, is_area=True)} (eq. Acero)", f"{format_num(props_homog['centroid_x'])}", f"{format_num(props_homog['centroid_y'])}",
                    f"{format_num(props_homog.get('inertia_x'), precision=3, is_inertia=True)} (eq. Acero)" if props_homog.get('inertia_x') else "N/A",
                    f"{format_num(props_homog.get('inertia_y'), precision=3, is_inertia=True)} (eq. Acero)" if props_homog.get('inertia_y') else "N/A"
                ]
            }
            df_results = pd.DataFrame(data)
            # Usar st.dataframe para una tabla más interactiva si se prefiere a markdown
            st.dataframe(df_results, hide_index=True, use_container_width=True)
            # st.markdown(df_results.to_markdown(index=False), unsafe_allow_html=True) # Alternativa Markdown


            # --- Visualización (con límites consistentes) ---
            st.subheader("🖼️ Visualización")

            # --- Calcular límites consistentes basados en geometría ORIGINAL ---
            plot_xlims, plot_ylims = None, None # Defaults
            if st.session_state.shapes:
                 all_orig_vertices = []
                 for shape in st.session_state.shapes:
                     try:
                         # Usar vértices originales (factor 1.0) para el bounding box global
                         all_orig_vertices.extend(shape.get_vertices(width_scale_factor=1.0))
                     except Exception as e:
                         st.warning(f"No se pudieron obtener vértices de {type(shape)} para límites: {e}")

                 if all_orig_vertices:
                     all_x = [v[0] for v in all_orig_vertices]
                     all_y = [v[1] for v in all_orig_vertices]
                     # Añadir origen (0,0) a los puntos considerados para los límites,
                     # para que los ejes suelan incluir el origen si está cerca.
                     all_x.append(0)
                     all_y.append(0)
                     global_min_x, global_max_x = min(all_x), max(all_x)
                     global_min_y, global_max_y = min(all_y), max(all_y)

                     # Calcular márgenes (similar a como se hacía en plot_section)
                     delta_x = max(global_max_x - global_min_x, 20) # Rango mínimo un poco mayor?
                     delta_y = max(global_max_y - global_min_y, 20)
                     margin_x = delta_x * 0.15 + 10 # 15% + 10mm margen
                     margin_y = delta_y * 0.15 + 10
                     plot_xlims = (global_min_x - margin_x, global_max_x + margin_x)
                     plot_ylims = (global_min_y - margin_y, global_max_y + margin_y)
            # --- Fin del cálculo de límites ---


            # --- Mostrar Plots usando los límites calculados ---
            plot_col1, plot_col2 = st.columns(2)

            with plot_col1:
                 st.write("**Sección Original**")
                 st.caption("CDG Original marcado en rojo.")
                 try:
                     fig_orig = plot_section(
                         st.session_state.shapes, title="Sección Original",
                         highlight_centroid={'x': props_orig['centroid_x'], 'y': props_orig['centroid_y']},
                         centroid_label="CDG Orig.",
                         xlims=plot_xlims, # <-- Pasar límites calculados
                         ylims=plot_ylims  # <-- Pasar límites calculados
                     )
                     st.pyplot(fig_orig, use_container_width=True)
                 except Exception as plot_err: st.error(f"Err Graf Orig: {plot_err}")

            with plot_col2:
                 st.write(f"**Visual. Homogeneizada**")
                 st.caption(f"Hormigón (ancho/{n_display}). CDG Homog. en rojo.")
                 try:
                     fig_homog_vis = plot_section(
                         st.session_state.shapes, title="Visual. Homog. (H->A)",
                         homogenize_visual=True, modular_ratio=n,
                         highlight_centroid={'x': props_homog['centroid_x'], 'y': props_homog['centroid_y']},
                         centroid_label="CDG Homog.",
                         xlims=plot_xlims, # <-- Pasar MISMOS límites calculados
                         ylims=plot_ylims  # <-- Pasar MISMOS límites calculados
                     )
                     st.pyplot(fig_homog_vis, use_container_width=True)
                 except Exception as plot_err: st.error(f"Err Graf Homog: {plot_err}")

        except (ValueError, AttributeError, TypeError) as calc_err:
            st.error(f"Error en cálculo/definición: {calc_err}")
        except Exception as e:
            st.error(f"Error inesperado en análisis: {e}")
            # import traceback; st.code(traceback.format_exc()) # Para depuración

    elif not st.session_state.shapes:
        st.info("Añada componentes geométricos para ver los resultados.")
    elif n <= 0 and isinstance(n, (int, float)): # Solo mostrar si n es numérico inválido
         st.error("La relación modular 'n' no es válida. Verifique fck y Es.")


# --- Pié de Página o Sidebar ---
st.sidebar.header("Acerca de")
st.sidebar.info(
    """
    **Analizador de Secciones Mixtas v0.5**

    Calcula propiedades geométricas de secciones compuestas.
    - Homogeneización: Hormigón -> Acero (Prop. / n).
    - Inercias: Respecto a ejes centroidales globales.
    - Visualización: Original y Homogeneizada (lado a lado, escala común).
    - Edición y Apilado Básico.
    - Deshacer cambios.
    """
)
st.sidebar.markdown("---")
# Actualizar fecha/lugar dinámicamente
try:
     # Intentar locale español si está disponible
     locale.setlocale(locale.LC_TIME, 'es_ES.UTF-8')
except locale.Error:
     try:
         locale.setlocale(locale.LC_TIME, 'es_ES')
     except locale.Error:
         print("Locale 'es_ES' no disponible, usando default.")
         pass # Usar locale por defecto del sistema si falla el español

now = datetime.now()
current_date_str = now.strftime("%A, %d de %B de %Y - %H:%M:%S") # Añadir segundos
st.sidebar.markdown(f"*{current_date_str} (Cáceres, España)*")
st.sidebar.caption(f"Streamlit v{st.__version__} | Pandas v{pd.__version__} | Matplotlib v{plt.matplotlib.__version__}")